<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AltMesh</title>
    <style>
        .font-mono {
            font-family: monospace;
        }

        .text-bu {
            color: #87c244;
        }

        .text-le {
            color: #f0811e;
        }

        .text-ac {
            color: #23acd6;
        }

        .text-md {
            color: #7bc9c2;
        }

        .text-pa {
            color: #659ed1;
        }

        .text-th {
            color: #6e72b4;
        }

        .text-gp {
            color: #afaeae;
        }
    </style>
</head>

<body>
    <h1>AltMesh</h1>
    <button id="connect">Connect</button>
    <button id="connect-bu"><span class="font-mono text-bu">&#x25A0;</span>Button</button>
    <button id="connect-le"><span class="font-mono text-le">&#x25A0;</span>LED</button>
    <button id="connect-ac"><span class="font-mono text-ac">&#x25A0;</span>Move</button>
    <button id="connect-md"><span class="font-mono text-md">&#x25A0;</span>Motion</button>
    <button id="connect-pa"><span class="font-mono text-pa">&#x25A0;</span>Brightness</button>
    <button id="connect-th"><span class="font-mono text-th">&#x25A0;</span>Temperature & Humidity</button>
    <button id="connect-gp"><span class="font-mono text-gp">&#x25A0;</span>GPIO</button>
    <div id="device-info">
    </div>
    <div id="notification-info"></div>
    <script>
        class AltMesh {
            constructor(name_prefix = 'MESH-100') {
                this.name_prefix = name_prefix;
                this.listeners = {};
            }

            addEventListener(type, listener) {
                if (typeof this.listeners[type] === 'undefined') {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(listener);
            }

            removeEventListener(type, listener) {
                if (typeof this.listeners[type] === 'undefined') {
                    this.listeners[type] = [];
                }
                this.listeners[type] = this.listeners[type].filter((e) => e !== listener);
            }

            dispatchEvent(type, ...args) {
                if (typeof this.listeners[type] === 'undefined') {
                    this.listeners[type] = [];
                }
                if (this.listeners[type].length === 0) {
                    console.debug('no listener for', type, args);
                } else {
                    try {
                        this.listeners[type].forEach((e) => e(...args));
                    } catch (error) {
                        console.error(error);
                    }
                }
            }

            async connect() {
                console.debug('>>>> connect');
                const SERVICE_UUID = '72c90001-57a9-4d40-b746-534e22ec9f9e';
                const CHARACTERISTIC_UUID_WRITE = '72c90004-57a9-4d40-b746-534e22ec9f9e';
                const CHARACTERISTIC_UUID_WRITE_WO_RESPONSE = '72c90002-57a9-4d40-b746-534e22ec9f9e';
                const CHARACTERISTIC_UUID_INDICATE = '72c90005-57a9-4d40-b746-534e22ec9f9e';
                const CHARACTERISTIC_UUID_NOTIFY = '72c90003-57a9-4d40-b746-534e22ec9f9e';
                const options = {
                    filters: [
                        { services: [SERVICE_UUID] },
                        { namePrefix: this.name_prefix }
                    ],
                    optionalServices: [SERVICE_UUID],
                };
                try {
                    this.device = await navigator.bluetooth.requestDevice(options);
                    this.device.addEventListener('gattserverdisconnected', async () => {
                        this.dispatchEvent('disconnect');
                    });
                    console.log('device name', this.device.name);
                    this.server = await this.device.gatt.connect();
                    this.service = await this.server.getPrimaryService(SERVICE_UUID);
                    this.characteristics = await this.service.getCharacteristics();
                    this.characteristic_write = await this.service.getCharacteristic(CHARACTERISTIC_UUID_WRITE);
                    this.characteristic_write_wo_response = await this.service.getCharacteristic(CHARACTERISTIC_UUID_WRITE_WO_RESPONSE);
                    this.characteristic_indicate = await this.service.getCharacteristic(CHARACTERISTIC_UUID_INDICATE);
                    this.characteristic_notify = await this.service.getCharacteristic(CHARACTERISTIC_UUID_NOTIFY);

                    this.characteristic_indicate.addEventListener('characteristicvaluechanged', async (event) => {
                        const buffer = Array(event.target.value.byteLength).fill();
                        const command_frame = buffer.map((_, i) => event.target.value.getUint8(i));
                        this.dispatchEvent('indicate', command_frame);
                    });
                    this.characteristic_notify.addEventListener('characteristicvaluechanged', async (event) => {
                        const buffer = Array(event.target.value.byteLength).fill();
                        const command_frame = buffer.map((_, i) => event.target.value.getUint8(i));
                        this.dispatchEvent('notify', command_frame);
                    });
                    this.characteristic_indicate.startNotifications();
                    this.characteristic_notify.startNotifications();
                } catch (error) {
                    console.error(error);
                }
                console.debug('<<<< connect');
            }

            async write_with_response(data, append_checksum = true) {
                console.debug('>>>> write_with_response', data, append_checksum);
                let command_frame = data;
                if (append_checksum) {
                    const sum = command_frame.reduce((a, c) => a + c, 0);
                    command_frame = command_frame.concat([sum & 0xFF]);
                }
                try {
                    const value = new Uint8Array(command_frame);
                    await this.characteristic_write.writeValue(value);
                } catch (error) {
                    console.error(error);
                }
                console.debug('<<<< write_with_response');
            }

            async write(data, append_checksum = true) {
                console.debug('>>>> write', data, append_checksum);
                let command_frame = data;
                if (append_checksum) {
                    const sum = command_frame.reduce((a, c) => a + c, 0);
                    command_frame = command_frame.concat([sum & 0xFF]);
                }
                try {
                    console.log('writing:', command_frame);
                    const value = new Uint8Array(command_frame);
                    await this.characteristic_write_wo_response.writeValue(value);
                } catch (error) {
                    console.error(error);
                }
                console.debug('<<<< write');
            }
        }

        class AltMeshBase extends AltMesh {
            constructor(name_prefix = 'MESH-100') {
                super(name_prefix);
                this.block_type = null;

                const verify = (data) => {
                    if (data.length < 3) {
                        throw new Error('length error');
                    }
                    const sum = data.reduce((a, c) => a + c, 0);
                    const last = data.slice(-1)[0];
                    if ((sum - last) & 0xFF == last) {
                        throw new Error('checksum error');
                    }
                    return true;
                }
                this.addEventListener('indicate', async (data) => {
                    // console.debug('>>>> indicate', data);
                    verify(data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x00, 0x02, 16].toString()) {
                        const connected = (this.block_type === null);
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const toVersionString = (bs) => bs.map((e) => e.toString()).join('.');
                        this.block_type = data[2];
                        this.dispatchEvent('blocktype', data[2]);
                        this.dispatchEvent('serialnumber', toUintLE(data.slice(3, 7)));
                        this.dispatchEvent('version', toVersionString(data.slice(7, 10)));
                        this.dispatchEvent('batterylevel', data[14] * 10);
                        if (connected) {
                            this.dispatchEvent('blocktypedetected', data[2]);
                        }
                    }
                    // console.debug('<<<< indicate');
                });
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    verify(data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x00, 0x00, 4].toString()) {
                        this.dispatchEvent('batterylevel', data[2] * 10);
                    }
                    if (id === [0x00, 0x01, 4].toString()) {
                        this.dispatchEvent('statusbutton', data[2]);
                    }
                    if (id === [0x00, 0x02, 16].toString()) {
                        this.dispatchEvent('blocktype', data[2]);
                        this.dispatchEvent('serialnumber', data.slice(3, 7).map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0));
                        this.dispatchEvent('version', data.slice(7, 10).map((e) => e.toString()).join('.'));
                        this.dispatchEvent('batterylevel', data[14] * 10);
                    }
                    // console.debug('<<<< notify');
                });
            }
            // Base write
            // - ステータスバーの点灯: 0x00, 0x00, redOnOff, greenOnOff, blueOnOff, statusbarOnOff
            // - ブロック機能の有効化: 0x00, 0x02, blockOnOff
            // - ブロックへの応答要求: 0x00, 0x03, 0x00
            // - ステータスバーの有効化 / 無効化: 0x00, 0x04, statusbarOnOff
            // - ブロックの電源オフ: 0x00, 0x05, 0x00
        }

        // 0x02: BU, #87c244
        class AltMeshButton extends AltMeshBase {
            constructor(callback) {
                super('MESH-100BU');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 4].toString()) {
                        this.dispatchEvent('button', data[2]);
                    }
                    // console.debug('<<<< notify');
                });
            }
        }

        // 0x00: LE, #f0811e
        class AltMeshLED extends AltMeshBase {
            constructor() {
                super('MESH-100LE');
            }
            // LED write
            // - LED点灯指示: 0x01, 0x00, red[2], green[2], blue[2], ontime[2], oncycle[2], offcycle[2], pattern
        }

        // 0x01: AC, #7bc9c2
        class AltMeshMove extends AltMeshBase {
            constructor(callback) {
                super('MESH-100AC');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 17].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const acc = [2, 4, 6].map((e) => toUintLE(data.slice(e, e + 2))).map((e) => ((e <= 0x7FFF) ? e : e - 0x10000) / 1024.0);
                        this.dispatchEvent('tap', acc[0], acc[1], acc[2]);
                    }
                    if (id === [0x01, 0x01, 17].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const acc = [2, 4, 6].map((e) => toUintLE(data.slice(e, e + 2))).map((e) => ((e <= 0x7FFF) ? e : e - 0x10000) / 1024.0);
                        this.dispatchEvent('shake', acc[0], acc[1], acc[2]);
                    }
                    if (id === [0x01, 0x02, 17].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const acc = [2, 4, 6].map((e) => toUintLE(data.slice(e, e + 2))).map((e) => ((e <= 0x7FFF) ? e : e - 0x10000) / 1024.0);
                        this.dispatchEvent('flip', acc[0], acc[1], acc[2]);
                    }
                    if (id === [0x01, 0x03, 17].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const acc = [2, 4, 6].map((e) => toUintLE(data.slice(e, e + 2))).map((e) => ((e <= 0x7FFF) ? e : e - 0x10000) / 1024.0);
                        this.dispatchEvent('orientation', data[2], acc[0], acc[1], acc[2]);
                    }
                    // console.debug('<<<< notify');
                });
            }
        }

        // 0x10: MD, #23acd6
        class AltMeshMotion extends AltMeshBase {
            constructor(callback) {
                super('MESH-100MD');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 6].toString()) {
                        this.dispatchEvent('motion', data[2], data[3], data[4]);
                    }
                    // console.debug('<<<< notify');
                });
            }
            // Motion write
            // - モード設定: 0x01, 0x00, requestId, mode, keep[2], judge[2]
        }

        // 0x11: PA, #659ed1
        class AltMeshBrightness extends AltMeshBase {
            constructor(callback) {
                super('MESH-100PA');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 13].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        this.dispatchEvent('brightness', data[2], toUintLE(data.slice(3, 5)), toUintLE(data.slice(5, 7)) * 10);
                    }
                    // console.debug('<<<< notify');
                });
            }
            // Brightness write
            // - モード設定: 0x01, 0x00, requestId, 0x00[10], 0x02[3], mode
        }

        // 0x12: TH, #6e72b4
        class AltMeshTempHumid extends AltMeshBase {
            constructor(callback) {
                super('MESH-100TH');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 9].toString()) {
                        const toUintLE = (bs) => bs.map((e, i) => (e << (8 * i))).reduce((a, c) => a + c, 0);
                        const toIntLE = (bs) => { const u = toUintLE(bs); return (u <= 0x7FFF) ? u : (u - 0x10000); };
                        const sensor = [4, 6].map((e) => toIntLE(data.slice(e, e + 2)));
                        this.dispatchEvent('temphumid', data[2], data[3], sensor[0] / 10.0, sensor[1]);
                    }
                    // console.debug('<<<< notify');
                });
            }
            // TempHumid write
            // - モード設定: 0x01, 0x00, requestId, tempTop[2], tempBottom[2], humidTop[2], humidBottom[2], tempCond, humidCond, mode
        }

        // 0x09: GP, #afaeae
        class AltMeshGPIO extends AltMeshBase {
            constructor(callback) {
                super('MESH-100GP');
                this.addEventListener('blocktypedetected', callback);
                this.addEventListener('notify', (data) => {
                    // console.debug('>>>> notify', data);
                    const id = [data.slice(0, 2), data.length].flat().toString();
                    if (id === [0x01, 0x00, 5].toString()) {
                        this.dispatchEvent('digitalchanged', data[2], data[3]);
                    }
                    if (id === [0x01, 0x01, 7].toString()) {
                        this.dispatchEvent('analogchanged', data[2], data[5]);
                    }
                    if (id === [0x01, 0x02, 6].toString()) {
                        this.dispatchEvent('digitalinput', data[2], data[3], data[4]);
                    }
                    if (id === [0x01, 0x03, 7].toString()) {
                        this.dispatchEvent('analoginput', data[2], data[3], data[4], data[5]);
                    }
                    if (id === [0x01, 0x04, 6].toString()) {
                        this.dispatchEvent('poweroutput', data[2], data[3], data[4]);
                    }
                    if (id === [0x01, 0x05, 6].toString()) {
                        this.dispatchEvent('digitaloutput', data[2], data[3], data[4]);
                    }
                    if (id === [0x01, 0x06, 6].toString()) {
                        this.dispatchEvent('pwmoutput', data[2], data[3], data[4]);
                    }
                    // console.debug('<<<< notify');
                });
            }
            // GPIO write
            // - 入出力設定: 0x01, 0x01, digRisingEdge, digFallingEdge, dig, pwm, power, anaRisingEdge, anaFallingEdge, anaCond
            // - デジタル入力の状態通知設定: 0x01, 0x02, requestId, dig
            // - アナログ入力の状態通知設定: 0x01, 0x03, requestId, mode
            // - 電源出力の状態通知設定: 0x01, 0x04, requestId, 0x00
            // - デジタル出力の状態通知設定: 0x01, 0x05, requestId, dig 
            // - PWM 出力の状態通知設定: 0x01, 0x06, requestId, 0x02
        }
    </script>
    <script>
        let devices = [];
        document.ble_devices = devices;
        document.querySelector('#connect').addEventListener('click', async () => {
            const device = new AltMeshBase();
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-bu').addEventListener('click', async () => {
            const device = new AltMeshButton(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
            });
            device.addEventListener('button', (status) => {
                const status_name = { 0x01: 'singlepress', 0x02: 'longpress', 0x03: 'doublepress' }[status];
                console.log(`button: ${status_name}`);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-le').addEventListener('click', async () => {
            const device = new AltMeshLED(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-ac').addEventListener('click', async () => {
            const device = new AltMeshMove(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
            });
            device.addEventListener('tap', (accx, accy, accz) => {
                console.log(`tap: x=${accx}, y=${accy}, z=${accz}`);
            });
            device.addEventListener('shake', (accx, accy, accz) => {
                console.log(`shake: x=${accx}, y=${accy}, z=${accz}`);
            });
            device.addEventListener('flip', (accx, accy, accz) => {
                console.log(`flip: x=${accx}, y=${accy}, z=${accz}`);
            });
            device.addEventListener('orientation', (orientation, accx, accy, accz) => {
                console.log(`orientation: ${orientation}, x=${accx}, y=${accy}, z=${accz}`);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-md').addEventListener('click', async () => {
            const device = new AltMeshMotion(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-pa').addEventListener('click', async () => {
            const device = new AltMeshBrightness(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-th').addEventListener('click', async () => {
            const device = new AltMeshTempHumid(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
                await device.write([0x01, 0x00, 0x01, 0x2C, 0x81, 0xB4, 0x80, 0x64, 0x00, 0x32, 0x00, 0x00, 0x01, 0x20]);
            });
            device.addEventListener('temphumid', (reqid, mode, temp, humid) => {
                console.log(`temphumid: ${temp}\u2103 ${humid}%`);
            });
            await device.connect();
            devices.push(device);
        });
        document.querySelector('#connect-gp').addEventListener('click', async () => {
            const device = new AltMeshGPIO(async (data) => {
                await device.write_with_response([0x00, 0x02, 0x01]);
                await device.write([0x01, 0x01, 0x07, 0x07, 0x00, 0x00, 0x02, 0x7F, 0x00, 0x01]);
            });
            await device.connect();
            devices.push(device);
        });
    </script>
</body>

</html>